"use strict";(self.webpackChunkdoeks_website=self.webpackChunkdoeks_website||[]).push([["2919"],{80518:function(e,r,a){a.d(r,{ZP:()=>i,d$:()=>t});var n=a(85893),s=a(50065);let t=[];function o(e){let r={code:"code",em:"em",p:"p",...(0,s.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(r.p,{children:["Once our sample data is uploaded you can run the Spark job. You will need to\nreplace the ",(0,n.jsx)(r.em,{children:"<S3_BUCKET>"})," placeholders in this file with the name of the bucket\ncreated earlier. You can get that value by running ",(0,n.jsx)(r.code,{children:"echo $S3_BUCKET"}),"."]}),"\n",(0,n.jsx)(r.p,{children:"To do this automatically you can run the following, which will create a .old\nbackup file and do the replacement for you."})]})}function i(e={}){let{wrapper:r}={...(0,s.a)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(o,{...e})}):o(e)}},74909:function(e,r,a){a.d(r,{ZP:()=>i,d$:()=>t});var n=a(85893),s=a(50065);let t=[];function o(e){let r={code:"code",em:"em",p:"p",pre:"pre",...(0,s.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(r.p,{children:["Run the ",(0,n.jsx)(r.em,{children:"taxi-trip-execute.sh"})," script with the following input. You will use the ",(0,n.jsx)(r.em,{children:"S3_BUCKET"})," variable created earlier. Additionally, you must change YOUR_REGION_HERE with the region of your choice, ",(0,n.jsx)(r.em,{children:"us-west-2"})," for example."]}),"\n",(0,n.jsx)(r.p,{children:"This script will download some example taxi trip data and create duplicates of\nit in order to increase the size a bit. This will take a bit of time and will\nrequire a relatively fast internet connection."}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-bash",children:"cd ${DOEKS_HOME}/analytics/scripts/\nchmod +x taxi-trip-execute.sh\n./taxi-trip-execute.sh ${S3_BUCKET} YOUR_REGION_HERE\n"})}),"\n",(0,n.jsx)(r.p,{children:"You can return to the blueprint directory and continue with the example"}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-bash",children:"cd ${DOEKS_HOME}/analytics/terraform/spark-k8s-operator\n"})})]})}function i(e={}){let{wrapper:r}={...(0,s.a)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(o,{...e})}):o(e)}},26885:function(e,r,a){a.r(r),a.d(r,{frontMatter:()=>h,default:()=>g,toc:()=>m,metadata:()=>n,assets:()=>u,contentTitle:()=>p});var n=JSON.parse('{"id":"blueprints/data-analytics/spark-operator-yunikorn","title":"Spark Operator with YuniKorn","description":"Introduction","source":"@site/docs/blueprints/data-analytics/spark-operator-yunikorn.md","sourceDirName":"blueprints/data-analytics","slug":"/blueprints/data-analytics/spark-operator-yunikorn","permalink":"/data-on-eks/docs/blueprints/data-analytics/spark-operator-yunikorn","draft":false,"unlisted":false,"editUrl":"https://github.com/awslabs/data-on-eks/blob/main/website/docs/blueprints/data-analytics/spark-operator-yunikorn.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"sidebar_label":"Spark Operator with YuniKorn","hide_table_of_contents":true},"sidebar":"blueprints","previous":{"title":"Introduction","permalink":"/data-on-eks/docs/blueprints/data-analytics/"},"next":{"title":"Spark Operator on EKS with IPv6","permalink":"/data-on-eks/docs/blueprints/data-analytics/spark-eks-ipv6"}}'),s=a(85893),t=a(50065),o=a(47902),i=a(5525),l=a(96912),c=a(74909),d=a(80518);a(62834);let h={sidebar_position:2,sidebar_label:"Spark Operator with YuniKorn",hide_table_of_contents:!0},p="Spark Operator with YuniKorn",u={},m=[{value:"Introduction",id:"introduction",level:2},{value:"Prerequisites",id:"prerequisites",level:3},{value:"Deploy",id:"deploy",level:3},{value:"Put sample data in S3",id:"put-sample-data-in-s3",level:2},...c.d$,{value:"NVMe Ephemeral SSD disk for Spark shuffle storage",id:"nvme-ephemeral-ssd-disk-for-spark-shuffle-storage",level:2},...d.d$,{value:"EBS Dynamic PVC for shuffle storage",id:"ebs-dynamic-pvc-for-shuffle-storage",level:2},...d.d$,{value:"Apache YuniKorn Gang Scheduling with NVMe based SSD disk for shuffle storage",id:"apache-yunikorn-gang-scheduling-with-nvme-based-ssd-disk-for-shuffle-storage",level:2},...d.d$,{value:"Using Karpenter Nodepool weights for running Spark Jobs on both AWS Graviton and Intel EC2 Instances",id:"using-karpenter-nodepool-weights-for-running-spark-jobs-on-both-aws-graviton-and-intel-ec2-instances",level:2},{value:"Solution",id:"solution",level:4}];function f(e){let r={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",span:"span",strong:"strong",ul:"ul",...(0,t.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.header,{children:(0,s.jsx)(r.h1,{id:"spark-operator-with-yunikorn",children:"Spark Operator with YuniKorn"})}),"\n",(0,s.jsx)(r.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(r.p,{children:"The EKS Cluster design for the Data on EKS blueprint is optimized for running Spark applications with Spark Operator and Apache YuniKorn as the batch scheduler. This blueprint leverage Karpenter to scale the worker nodes, AWS for FluentBit is employed for logging, and a combination of Prometheus, Amazon Managed Prometheus, and open source Grafana are used for observability. Additionally, the Spark History Server Live UI is configured for monitoring running Spark jobs through an NLB and NGINX ingress controller."}),"\n",(0,s.jsxs)(l.Z,{header:(0,s.jsx)(r.h2,{children:(0,s.jsx)(r.span,{children:"Spark workloads with Karpenter"})}),children:[(0,s.jsx)(r.p,{children:"Using Karpenter as the autoscaler, eliminates the need for Managed Node Groups and Cluster Autoscaler for the Spark workloads. In this design, Karpenter and its Nodepools are responsible for creating both On-Demand and Spot instances, dynamically selecting instance types based on user demands. Karpenter offers improved performance compared to Cluster Autoscaler, with more efficient node scaling and faster response times. Karpenter's key features include its ability to scale from zero, optimizing resource utilization and reducing costs when there is no demand for resources. Additionally, Karpenter supports multiple Nodepools, allowing for greater flexibility in defining the required infrastructure for different workload types, such as compute, memory, and GPU-intensive tasks. Furthermore, Karpenter integrates seamlessly with Kubernetes, providing automatic, real-time adjustments to the cluster size based on observed workloads and scaling events. This enables a more efficient and cost-effective EKS cluster design that adapts to the ever-changing demands of Spark applications and other workloads."}),(0,s.jsx)(r.p,{children:(0,s.jsx)(r.img,{alt:"img.png",src:a(13769).Z+"",width:"1398",height:"901"})}),(0,s.jsx)(r.p,{children:"The blueprint configures the Karpenter Nodepools and Ec2 classes in the tabs below."}),(0,s.jsxs)(o.Z,{children:[(0,s.jsxs)(i.Z,{value:"spark-memory-optimized",label:"spark-memory-optimized",children:[(0,s.jsx)(r.p,{children:"This NodePool uses the r5d instance type, from xlarge to 8xlarge sizes, which are great for Spark jobs require more memory."}),(0,s.jsxs)(r.p,{children:["To view the Karpenter configuration ",(0,s.jsxs)(r.a,{href:"https://github.com/awslabs/data-on-eks/blob/main/analytics/terraform/spark-k8s-operator/addons.tf#L177-L223",children:["review the ",(0,s.jsx)(r.code,{children:"addons.tf"})," file here"]})]})]}),(0,s.jsxs)(i.Z,{value:"spark-graviton-memory-optimized",label:"spark-graviton-memory-optimized",children:[(0,s.jsx)(r.p,{children:"This NodePool uses the r6g, r6gd, r7g, r7gd, and r8g instance type, from 4xlarge to 16xlarge sizes"}),(0,s.jsxs)(r.p,{children:["To view the Karpenter configuration ",(0,s.jsxs)(r.a,{href:"https://github.com/awslabs/data-on-eks/blob/main/analytics/terraform/spark-k8s-operator/addons.tf#L117-L170",children:["review the ",(0,s.jsx)(r.code,{children:"addons.tf"})," file here"]})]})]}),(0,s.jsxs)(i.Z,{value:"spark-compute-optimized",label:"spark-compute-optimized",children:[(0,s.jsx)(r.p,{children:"This NodePool uses the C5d instance type, from 4xlarge to 24xlarge sizes, which are great for Spark jobs require more CPU time."}),(0,s.jsxs)(r.p,{children:["To view the Karpenter configuration ",(0,s.jsxs)(r.a,{href:"https://github.com/awslabs/data-on-eks/blob/main/analytics/terraform/spark-k8s-operator/addons.tf#L63-L110",children:["review the ",(0,s.jsx)(r.code,{children:"addons.tf"})," file here"]})]})]}),(0,s.jsxs)(i.Z,{value:"spark-vertical-ebs-scale",label:"spark-vertical-ebs-scale",children:[(0,s.jsx)(r.p,{children:"This NodePool uses a broad range of EC2 instance types, and in the bootstrapping the instances create and mount a secondary EBS volume. This volume size is scaled based on the number of cores on the Ec2 instance.\nThis provides a secondary storage location that can be used for Spark workloads, reducing the load on the root volume of the instance and avoiding impact to system daemons or the kubelet. As larger nodes can accept more pods the bootstrapping creates a larger volume for the larger instances."}),(0,s.jsxs)(r.p,{children:["To view the Karpenter configuration ",(0,s.jsxs)(r.a,{href:"https://github.com/awslabs/data-on-eks/blob/main/analytics/terraform/spark-k8s-operator/addons.tf#L230-L355",children:["review the ",(0,s.jsx)(r.code,{children:"addons.tf"})," file here"]})]})]})]})]}),"\n",(0,s.jsxs)(l.Z,{header:(0,s.jsx)(r.h2,{children:(0,s.jsx)(r.span,{children:"NVMe SSD Instance Storage for Spark Shuffle data"})}),children:[(0,s.jsx)(r.p,{children:'It is important to note that the NodePools in this EKS Cluster design utilize NVMe SSD instance storage for each node to serve as shuffle storage for Spark workloads. These high-performance storage options are available with all "d" type instances.'}),(0,s.jsx)(r.p,{children:"The use of NVMe SSD instance storage as shuffle storage for Spark brings numerous advantages. First, it provides low-latency and high-throughput data access, significantly improving Spark's shuffle performance. This results in faster job completion times and enhanced overall application performance. Second, the use of local SSD storage reduces the reliance on remote storage systems, such as EBS volumes, which can become a bottleneck during shuffle operations. This also reduces the costs associated with provisioning and managing additional EBS volumes for shuffle data. Finally, by leveraging NVMe SSD storage, the EKS cluster design offers better resource utilization and increased performance, allowing Spark applications to process larger datasets and tackle more complex analytics workloads more efficiently. This optimized storage solution ultimately contributes to a more scalable and cost-effective EKS cluster tailored for running Spark workloads on Kubernetes."}),(0,s.jsxs)(r.p,{children:["The NVMe SSD instance storage is configured by the bootstrapping scripts when the instance launches (",(0,s.jsxs)(r.a,{href:"https://karpenter.sh/docs/concepts/nodeclasses/#specinstancestorepolicy",children:["the Karpenter NodePools are configured with ",(0,s.jsx)(r.code,{children:"instanceStorePolicy: RAID0"})]}),"). The NVMe devices are combined into a single RAID0 (striped) array then mounted to ",(0,s.jsx)(r.code,{children:"/mnt/k8s-disks/0"}),". This directory is further linked with ",(0,s.jsx)(r.code,{children:"/var/lib/kubelet"}),",",(0,s.jsx)(r.code,{children:" /var/lib/containerd"})," and ",(0,s.jsx)(r.code,{children:"/var/log/pods"}),", ensuring that all data written to those locations is stored on the NVMe devices. Because data written inside of a pod will be written to one of these directories the Pods benefit from high-performance storage without having to leverage hostPath mounts or PersistentVolumes"]})]}),"\n",(0,s.jsxs)(l.Z,{header:(0,s.jsx)(r.h2,{children:(0,s.jsx)(r.span,{children:"Spark Operator"})}),children:[(0,s.jsx)(r.p,{children:"The Kubernetes Operator for Apache Spark aims to make specifying and running Spark applications as easy and idiomatic as running other workloads on Kubernetes."}),(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"a SparkApplication controller that watches events of creation, updates, and deletion of SparkApplication objects and acts on the watch events,"}),"\n",(0,s.jsx)(r.li,{children:"a submission runner that runs spark-submit for submissions received from the controller,"}),"\n",(0,s.jsx)(r.li,{children:"a Spark pod monitor that watches for Spark pods and sends pod status updates to the controller,"}),"\n",(0,s.jsx)(r.li,{children:"a Mutating Admission Webhook that handles customizations for Spark driver and executor pods based on the annotations on the pods added by the controller,"}),"\n",(0,s.jsx)(r.li,{children:"and also a command-line tool named sparkctl for working with the operator."}),"\n"]}),(0,s.jsx)(r.p,{children:"The following diagram shows how different components of Spark Operator add-on interact and work together."}),(0,s.jsx)(r.p,{children:(0,s.jsx)(r.img,{alt:"img.png",src:a(66678).Z+"",width:"960",height:"540"})})]}),"\n",(0,s.jsxs)(l.Z,{header:(0,s.jsx)(r.h2,{children:(0,s.jsx)(r.span,{children:"Deploying the Solution"})}),children:[(0,s.jsxs)(r.p,{children:["In this ",(0,s.jsx)(r.a,{href:"https://github.com/awslabs/data-on-eks/tree/main/analytics/terraform/spark-k8s-operator",children:"example"}),", you will provision the following resources required to run Spark Jobs with open source Spark Operator and Apache YuniKorn."]}),(0,s.jsx)(r.p,{children:"This example deploys an EKS Cluster running the Spark K8s Operator into a new VPC."}),(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Creates a new sample VPC, 2 Private Subnets, 2 Public Subnets, and 2 subnets in the RFC6598 space (100.64.0.0/10) for EKS Pods."}),"\n",(0,s.jsx)(r.li,{children:"Creates Internet gateway for Public Subnets and NAT Gateway for Private Subnets"}),"\n",(0,s.jsx)(r.li,{children:"Creates EKS Cluster Control plane with public endpoint (for demo reasons only) with Managed Node Groups for benchmarking and core services, and Karpenter NodePools for Spark workloads."}),"\n",(0,s.jsx)(r.li,{children:"Deploys Metrics server, Spark-operator, Apache Yunikorn, Karpenter, Cluster Autoscaler, Grafana, AMP and Prometheus server."}),"\n"]}),(0,s.jsx)(r.h3,{id:"prerequisites",children:"Prerequisites"}),(0,s.jsx)(r.p,{children:"Ensure that you have installed the following tools on your machine."}),(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2.html",children:"aws cli"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://Kubernetes.io/docs/tasks/tools/",children:"kubectl"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://learn.hashicorp.com/tutorials/terraform/install-cli",children:"terraform"})}),"\n"]}),(0,s.jsx)(r.h3,{id:"deploy",children:"Deploy"}),(0,s.jsx)(r.p,{children:"Clone the repository."}),(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"git clone https://github.com/awslabs/data-on-eks.git\ncd data-on-eks\nexport DOEKS_HOME=$(pwd)\n"})}),(0,s.jsxs)(r.p,{children:["If DOEKS_HOME is ever unset, you can always set it manually using ",(0,s.jsx)(r.code,{children:"export DATA_ON_EKS=$(pwd)"})," from your data-on-eks directory."]}),(0,s.jsxs)(r.p,{children:["Navigate into one of the example directories and run ",(0,s.jsx)(r.code,{children:"install.sh"})," script."]}),(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"cd ${DOEKS_HOME}/analytics/terraform/spark-k8s-operator\nchmod +x install.sh\n./install.sh\n"})}),(0,s.jsx)(r.p,{children:"Now create an S3_BUCKET variable that holds the name of the bucket created\nduring the install. This bucket will be used in later examples to store output\ndata. If S3_BUCKET is ever unset, you can run the following commands again."}),(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"export S3_BUCKET=$(terraform output -raw s3_bucket_id_spark_history_server)\necho $S3_BUCKET\n"})})]}),"\n",(0,s.jsxs)(l.Z,{header:(0,s.jsx)(r.h2,{children:(0,s.jsx)(r.span,{children:"Execute Sample Spark job with Karpenter"})}),children:[(0,s.jsxs)(r.p,{children:["Navigate to example directory. You will need to replace the ",(0,s.jsx)(r.code,{children:"<S3_BUCKET>"})," placeholders in this file with the name of the bucket created earlier. You can get that value by running echo $S3_BUCKET."]}),(0,s.jsx)(r.p,{children:"To do this automatically you can run the following, which will create a .old backup file and do the replacement for you."}),(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"sed -i.old s/\\<S3_BUCKET\\>/${S3_BUCKET}/g ./pyspark-pi-job.yaml\n"})}),(0,s.jsx)(r.p,{children:"Submit the Spark Job"}),(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"cd ${DOEKS_HOME}/analytics/terraform/spark-k8s-operator/examples/karpenter\nkubectl apply -f pyspark-pi-job.yaml\n"})}),(0,s.jsx)(r.p,{children:"Monitor the job status using the below command.\nYou should see the new nodes triggered by the karpenter and the YuniKorn will schedule one driver pod and 2 executor pods on this node."}),(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"kubectl get pods -n spark-team-a -w\n"})}),(0,s.jsx)(r.p,{children:"You can check the status of the SparkApplication if the pods are already completed:"}),(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"kubectl describe sparkapplication pyspark-pi-karpenter -n spark-team-a\n"})}),(0,s.jsx)(r.p,{children:"You can try the following examples to leverage multiple Karpenter Nodepools, EBS as Dynamic PVC instead of SSD and YuniKorn Gang Scheduling."}),(0,s.jsx)(r.h2,{id:"put-sample-data-in-s3",children:"Put sample data in S3"}),(0,s.jsx)(c.ZP,{}),(0,s.jsx)(r.h2,{id:"nvme-ephemeral-ssd-disk-for-spark-shuffle-storage",children:"NVMe Ephemeral SSD disk for Spark shuffle storage"}),(0,s.jsx)(r.p,{children:"Example PySpark job that uses NVMe based ephemeral SSD disk for Driver and Executor shuffle storage"}),(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"cd ${DOEKS_HOME}/analytics/terraform/spark-k8s-operator/examples/karpenter/\n"})}),(0,s.jsx)(d.ZP,{filename:"./nvme-ephemeral-storage.yaml"}),(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"sed -i.old s/\\<S3_BUCKET\\>/${S3_BUCKET}/g ./nvme-ephemeral-storage.yaml\n"})}),(0,s.jsx)(r.p,{children:"Now that the bucket name is in place you can create the Spark job."}),(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"kubectl apply -f nvme-ephemeral-storage.yaml\n"})}),(0,s.jsx)(r.h2,{id:"ebs-dynamic-pvc-for-shuffle-storage",children:"EBS Dynamic PVC for shuffle storage"}),(0,s.jsx)(r.p,{children:"Example PySpark job that uses EBS ON_DEMAND volumes using Dynamic PVCs for Driver and Executor shuffle storage"}),(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"cd ${DOEKS_HOME}/analytics/terraform/spark-k8s-operator/examples/karpenter/\n"})}),(0,s.jsx)(d.ZP,{filename:"./ebs-storage-dynamic-pvc.yaml"}),(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"sed -i.old s/\\<S3_BUCKET\\>/${S3_BUCKET}/g ./ebs-storage-dynamic-pvc.yaml\n"})}),(0,s.jsx)(r.p,{children:"Now that the bucket name is in place you can create the Spark job."}),(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"kubectl apply -f ebs-storage-dynamic-pvc.yaml\n"})}),(0,s.jsx)(r.h2,{id:"apache-yunikorn-gang-scheduling-with-nvme-based-ssd-disk-for-shuffle-storage",children:"Apache YuniKorn Gang Scheduling with NVMe based SSD disk for shuffle storage"}),(0,s.jsx)(r.p,{children:"Gang Scheduling Spark jobs using Apache YuniKorn and Spark Operator"}),(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"cd ${DOEKS_HOME}/analytics/terraform/spark-k8s-operator/examples/karpenter/\n"})}),(0,s.jsx)(d.ZP,{filename:"./nvme-storage-yunikorn-gang-scheduling.yaml"}),(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"sed -i.old s/\\<S3_BUCKET\\>/${S3_BUCKET}/g ./nvme-storage-yunikorn-gang-scheduling.yaml\n"})}),(0,s.jsx)(r.p,{children:"Now that the bucket name is in place you can create the Spark job."}),(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"kubectl apply -f nvme-storage-yunikorn-gang-scheduling.yaml\n"})})]}),"\n",(0,s.jsxs)(l.Z,{header:(0,s.jsx)(r.h2,{children:(0,s.jsx)(r.span,{children:"Karpenter Nodepool weights with Graviton and Intel"})}),children:[(0,s.jsx)(r.h2,{id:"using-karpenter-nodepool-weights-for-running-spark-jobs-on-both-aws-graviton-and-intel-ec2-instances",children:"Using Karpenter Nodepool weights for running Spark Jobs on both AWS Graviton and Intel EC2 Instances"}),(0,s.jsxs)(r.p,{children:["Customers often seek to leverage AWS Graviton instances for running Spark jobs due to their cost savings and performance improvements over traditional Intel instances. However, a common challenge is the availability of Graviton instances in specific regions or availability zones, especially during times of high demand. To address this, a ",(0,s.jsx)(r.a,{href:"https://karpenter.sh/docs/concepts/scheduling/#weighted-nodepools",children:"fallback strategy"})," to equivalent Intel instances is desirable."]}),(0,s.jsx)(r.h4,{id:"solution",children:"Solution"}),(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Step 1: Create a Multi-Architecture Spark Docker Image"}),"\nFirst, ensure that your Spark job can run on both AWS Graviton (ARM architecture) and Intel (AMD architecture) instances by creating a multi-architecture Docker image. You can find a sample ",(0,s.jsx)(r.a,{href:"../../../../analytics/terraform/spark-k8s-operator/examples/docker/Dockerfile",children:"Dockerfile"})," and ",(0,s.jsx)(r.a,{href:"https://github.com/awslabs/data-on-eks/tree/main/analytics/terraform/spark-k8s-operator/examples/docker",children:"instructions for building and pushing this image to Amazon Elastic Container Registry (ECR) in the examples directory"}),"."]}),(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Step 2: Deploy Two Karpenter Nodepools with weights"}),"\nDeploy two separate Karpenter Nodepools: one configured for Graviton instances and the other for Intel instances."]}),(0,s.jsxs)(r.p,{children:["Graviton Nodepool (ARM): Set the weight of the Graviton Nodepool to ",(0,s.jsx)(r.code,{children:"100"}),". This prioritizes Graviton instances for your Spark workloads."]}),(0,s.jsxs)(r.p,{children:["Intel Nodepool (AMD): Set the weight of the Intel Nodepool to ",(0,s.jsx)(r.code,{children:"50"}),". This ensures that Karpenter will fall back to the Intel Nodepool when Graviton instances are either unavailable or reach their maximum CPU capacity."]}),(0,s.jsx)(r.p,{children:"The memory optimized Karpenter NodePools are configured with these weights."}),(0,s.jsxs)(o.Z,{children:[(0,s.jsxs)(i.Z,{value:"spark-memory-optimized",label:"spark-memory-optimized",children:[(0,s.jsx)(r.p,{children:"This NodePool uses the r5d instance type, from xlarge to 8xlarge sizes, which are great for Spark jobs require more memory."}),(0,s.jsxs)(r.p,{children:["To view the Karpenter configuration ",(0,s.jsxs)(r.a,{href:"https://github.com/awslabs/data-on-eks/blob/main/analytics/terraform/spark-k8s-operator/addons.tf#L177-L223",children:["review the ",(0,s.jsx)(r.code,{children:"addons.tf"})," file here"]})]})]}),(0,s.jsxs)(i.Z,{value:"spark-graviton-memory-optimized",label:"spark-graviton-memory-optimized",children:[(0,s.jsx)(r.p,{children:"This NodePool uses the r6g, r6gd, r7g, r7gd, and r8g instance type, from 4xlarge to 16xlarge sizes"}),(0,s.jsxs)(r.p,{children:["To view the Karpenter configuration ",(0,s.jsxs)(r.a,{href:"https://github.com/awslabs/data-on-eks/blob/main/analytics/terraform/spark-k8s-operator/addons.tf#L117-L170",children:["review the ",(0,s.jsx)(r.code,{children:"addons.tf"})," file here"]})]})]})]}),(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Step 3: Use a label selector that targets both Nodepools"}),"\nSince both nodepools have the label ",(0,s.jsx)(r.code,{children:"multiArch: Spark"})," we can configure our Spark job with a NodeSelector that matches that label. This will allow Karpenter to provision nodes from both of memory-optimized nodepools, and it will start with the Graviton instances due to the weights configured above."]}),(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-yaml",children:"    nodeSelector:\n      multiArch: Spark\n"})})]}),"\n",(0,s.jsxs)(l.Z,{header:(0,s.jsx)(r.h2,{children:(0,s.jsx)(r.span,{children:"Cleanup"})}),children:[(0,s.jsx)(r.admonition,{type:"caution",children:(0,s.jsx)(r.p,{children:"To avoid unwanted charges to your AWS account, delete all the AWS resources created during this deployment"})}),(0,s.jsxs)(r.p,{children:["This script will cleanup the environment using ",(0,s.jsx)(r.code,{children:"-target"})," option to ensure all the resources are deleted in correct order."]}),(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"cd ${DOEKS_HOME}/analytics/terraform/spark-k8s-operator && chmod +x cleanup.sh\n./cleanup.sh\n"})})]})]})}function g(e={}){let{wrapper:r}={...(0,t.a)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(f,{...e})}):f(e)}},13769:function(e,r,a){a.d(r,{Z:()=>n});let n=a.p+"assets/images/eks-spark-operator-karpenter-e045e7b7342edb390b25147dc4c98dd6.png"},66678:function(e,r,a){a.d(r,{Z:()=>n});let n=a.p+"assets/images/spark-operator-6752098849b2e90ded1f19770c70f101.png"},5525:function(e,r,a){a.d(r,{Z:()=>t});var n=a(85893);a(67294);var s=a(67026);function t({children:e,hidden:r,className:a}){return(0,n.jsx)("div",{role:"tabpanel",className:(0,s.Z)("tabItem_Ymn6",a),hidden:r,children:e})}},47902:function(e,r,a){a.d(r,{Z:()=>b});var n=a(85893),s=a(67294),t=a(67026),o=a(69599),i=a(16550),l=a(32e3),c=a(4520),d=a(38341),h=a(76009);function p(e){return s.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,s.isValidElement)(e)&&function(e){let{props:r}=e;return!!r&&"object"==typeof r&&"value"in r}(e))return e;throw Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function u({value:e,tabValues:r}){return r.some(r=>r.value===e)}var m=a(7227);function f({className:e,block:r,selectedValue:a,selectValue:s,tabValues:i}){let l=[],{blockElementScrollPositionUntilNextRender:c}=(0,o.o5)(),d=e=>{let r=e.currentTarget,n=i[l.indexOf(r)].value;n!==a&&(c(r),s(n))},h=e=>{let r=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{let a=l.indexOf(e.currentTarget)+1;r=l[a]??l[0];break}case"ArrowLeft":{let a=l.indexOf(e.currentTarget)-1;r=l[a]??l[l.length-1]}}r?.focus()};return(0,n.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,t.Z)("tabs",{"tabs--block":r},e),children:i.map(({value:e,label:r,attributes:s})=>(0,n.jsx)("li",{role:"tab",tabIndex:a===e?0:-1,"aria-selected":a===e,ref:e=>{l.push(e)},onKeyDown:h,onClick:d,...s,className:(0,t.Z)("tabs__item","tabItem_LNqP",s?.className,{"tabs__item--active":a===e}),children:r??e},e))})}function g({lazy:e,children:r,selectedValue:a}){let o=(Array.isArray(r)?r:[r]).filter(Boolean);if(e){let e=o.find(e=>e.props.value===a);return e?(0,s.cloneElement)(e,{className:(0,t.Z)("margin-top--md",e.props.className)}):null}return(0,n.jsx)("div",{className:"margin-top--md",children:o.map((e,r)=>(0,s.cloneElement)(e,{key:r,hidden:e.props.value!==a}))})}function x(e){let r=function(e){let{defaultValue:r,queryString:a=!1,groupId:n}=e,t=function(e){let{values:r,children:a}=e;return(0,s.useMemo)(()=>{let e=r??p(a).map(({props:{value:e,label:r,attributes:a,default:n}})=>({value:e,label:r,attributes:a,default:n})),n=(0,d.lx)(e,(e,r)=>e.value===r.value);if(n.length>0)throw Error(`Docusaurus error: Duplicate values "${n.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`);return e},[r,a])}(e),[o,m]=(0,s.useState)(()=>(function({defaultValue:e,tabValues:r}){if(0===r.length)throw Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!u({value:e,tabValues:r}))throw Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${r.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}let a=r.find(e=>e.default)??r[0];if(!a)throw Error("Unexpected error: 0 tabValues");return a.value})({defaultValue:r,tabValues:t})),[f,g]=function({queryString:e=!1,groupId:r}){let a=(0,i.k6)(),n=function({queryString:e=!1,groupId:r}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!r)throw Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return r??null}({queryString:e,groupId:r});return[(0,c._X)(n),(0,s.useCallback)(e=>{if(!n)return;let r=new URLSearchParams(a.location.search);r.set(n,e),a.replace({...a.location,search:r.toString()})},[n,a])]}({queryString:a,groupId:n}),[x,b]=function({groupId:e}){let r=e?`docusaurus.tab.${e}`:null,[a,n]=(0,h.Nk)(r);return[a,(0,s.useCallback)(e=>{r&&n.set(e)},[r,n])]}({groupId:n}),k=(()=>{let e=f??x;return u({value:e,tabValues:t})?e:null})();return(0,l.Z)(()=>{k&&m(k)},[k]),{selectedValue:o,selectValue:(0,s.useCallback)(e=>{if(!u({value:e,tabValues:t}))throw Error(`Can't select invalid tab value=${e}`);m(e),g(e),b(e)},[g,b,t]),tabValues:t}}(e);return(0,n.jsxs)("div",{className:(0,t.Z)("tabs-container","tabList__CuJ"),children:[(0,n.jsx)(f,{...r,...e}),(0,n.jsx)(g,{...r,...e})]})}function b(e){let r=(0,m.Z)();return(0,n.jsx)(x,{...e,children:p(e.children)},String(r))}},96912:function(e,r,a){a.d(r,{Z:()=>d});var n=a(85893),s=a(67294),t=a(45697),o=a.n(t),i=a(67026);let l="expanded_iGsi";function c({children:e,header:r}){let[a,t]=(0,s.useState)(!1);return(0,n.jsxs)("div",{className:"collapsibleContent_q3kw",children:[(0,n.jsxs)("div",{className:(0,i.Z)("header_QCEw",{[l]:a}),onClick:()=>{t(!a)},children:[r,(0,n.jsx)("span",{className:(0,i.Z)("icon_PckA",{[l]:a}),children:a?"\uD83D\uDC47":"\uD83D\uDC48"})]}),a&&(0,n.jsx)("div",{className:"content_qLC1",children:e})]})}c.propTypes={children:o().node.isRequired,header:o().node.isRequired};let d=c}}]);
"use strict";(self.webpackChunkdoeks_website=self.webpackChunkdoeks_website||[]).push([[3666],{7490:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>l,toc:()=>c});var i=a(4848),t=a(8453),r=a(2450);const s={sidebar_position:1,sidebar_label:"Llama-2 with RayTrain on Trn1"},o="Llama2 Distributed Pre-training on Trn1 with RayTrain and KubeRay",l={id:"gen-ai/training/Neuron/RayTrain-Llama2",title:"RayTrain-Llama2",description:"The AI on EKS content is being migrated to a new repository.",source:"@site/docs/gen-ai/training/Neuron/RayTrain-Llama2.md",sourceDirName:"gen-ai/training/Neuron",slug:"/gen-ai/training/Neuron/RayTrain-Llama2",permalink:"/data-on-eks/docs/gen-ai/training/Neuron/RayTrain-Llama2",draft:!1,unlisted:!1,editUrl:"https://github.com/awslabs/data-on-eks/blob/main/website/docs/gen-ai/training/Neuron/RayTrain-Llama2.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,sidebar_label:"Llama-2 with RayTrain on Trn1"},sidebar:"genai",previous:{title:"Llama-3 with RayTrain on Trn1",permalink:"/data-on-eks/docs/gen-ai/training/Neuron/Llama-LoRA-Finetuning"},next:{title:"Llama-2 with Nemo-Megatron on Trn1",permalink:"/data-on-eks/docs/gen-ai/training/Neuron/Llama2"}},d={},c=[{value:"What is Llama-2?",id:"what-is-llama-2",level:3},{value:"Why RayTrain and KubeRay for Distributed Training?",id:"why-raytrain-and-kuberay-for-distributed-training",level:3},{value:"RayTrain:",id:"raytrain",level:4},{value:"KubeRay:",id:"kuberay",level:4},{value:"AWS Trainium:",id:"aws-trainium",level:4},{value:"Why This Combination is Powerful",id:"why-this-combination-is-powerful",level:3},{value:"What is Volcano?",id:"what-is-volcano",level:3},{value:"How Volcano Works with Gang Scheduling",id:"how-volcano-works-with-gang-scheduling",level:3},{value:"1. Deploying the Solution",id:"1-deploying-the-solution",level:2},{value:"Verify the resources",id:"verify-the-resources",level:3},{value:"2. Build the Docker Image (Optional Step)",id:"2-build-the-docker-image-optional-step",level:2},{value:"3. Launch the Ray Cluster with KubeRay Operator",id:"3-launch-the-ray-cluster-with-kuberay-operator",level:2},{value:"Gang Scheduling of Ray Head and Worker Pods with Volcano",id:"gang-scheduling-of-ray-head-and-worker-pods-with-volcano",level:3},{value:"Accessing the Ray Dashboard (Port Forwarding):",id:"accessing-the-ray-dashboard-port-forwarding",level:3},{value:"4. Generate Pre-training Data on FSx Shared Filesystem",id:"4-generate-pre-training-data-on-fsx-shared-filesystem",level:2},{value:"Monitoring the Job:",id:"monitoring-the-job",level:3},{value:"5. Run Pre-compilation Job (Optimization Step)",id:"5-run-pre-compilation-job-optimization-step",level:2},{value:"6. Run Distributed Pre-training Job",id:"6-run-distributed-pre-training-job",level:2},{value:"Cleaning up",id:"cleaning-up",level:3}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",p:"p",pre:"pre",span:"span",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.admonition,{type:"caution",children:(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.strong,{children:"AI on EKS"})," content ",(0,i.jsx)(n.strong,{children:"is being migrated"})," to a new repository.\n\ud83d\udd17 \ud83d\udc49 ",(0,i.jsx)(n.a,{href:"https://awslabs.github.io/data-on-eks/docs/migration/migration-announcement",children:"Read the full migration announcement \xbb"})]})}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsx)(n.p,{children:"Deployment of ML models on EKS requires access to GPUs or Neuron instances. If your deployment isn't working, it\u2019s often due to missing access to these resources. Also, some deployment patterns rely on Karpenter autoscaling and static node groups; if nodes aren't initializing, check the logs for Karpenter or Node groups to resolve the issue."})}),"\n",(0,i.jsx)(n.admonition,{type:"danger",children:(0,i.jsxs)(n.p,{children:["Note: Use of this Llama-2 model is governed by the Meta license.\nIn order to download the model weights and tokenizer, please visit the ",(0,i.jsx)(n.a,{href:"https://ai.meta.com/",children:"website"})," and accept the license before requesting access."]})}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsx)(n.p,{children:"We are actively enhancing this blueprint to incorporate improvements in observability, logging, and scalability aspects."})}),"\n",(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"llama2-distributed-pre-training-on-trn1-with-raytrain-and-kuberay",children:"Llama2 Distributed Pre-training on Trn1 with RayTrain and KubeRay"})}),"\n",(0,i.jsxs)(n.p,{children:["This comprehensive guide walks you through pre-training the ",(0,i.jsx)(n.code,{children:"Llama2-7B"})," language model using AWS Trainium (Trn1) instances and the AWS Neuron SDK within a KubeRay cluster on Amazon EKS. This is a tailored version of the original ",(0,i.jsx)(n.a,{href:"https://awsdocs-neuron.readthedocs-hosted.com/en/latest/libraries/neuronx-distributed/tutorials/training_llama2_7b.html#llama2-7b-tp-zero1-tutorial",children:"Llama2 pretraining tutorial"})," optimized for KubeRay's distributed training capabilities."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Llama2-RayTrain",src:a(2709).A+"",width:"14330",height:"7927"})}),"\n",(0,i.jsx)(n.h3,{id:"what-is-llama-2",children:"What is Llama-2?"}),"\n",(0,i.jsx)(n.p,{children:"Llama-2 is a state-of-the-art large language model (LLM) designed for various natural language processing (NLP) tasks, including text generation, summarization, translation, question answering, and more. It's a powerful tool that can be fine-tuned for specific use cases."}),"\n",(0,i.jsx)(n.h3,{id:"why-raytrain-and-kuberay-for-distributed-training",children:"Why RayTrain and KubeRay for Distributed Training?"}),"\n",(0,i.jsx)(n.p,{children:"Distributed training is essential for large models like Llama-2 due to their extensive computational and memory requirements. The combination of RayTrain and KubeRay, especially when leveraged with AWS Trainium, provides a robust framework for handling these demands efficiently and effectively:"}),"\n",(0,i.jsx)(n.h4,{id:"raytrain",children:"RayTrain:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Simplified Distributed Training"}),": RayTrain is a high-level library built on the Ray framework that abstracts the complexities of distributed training. It allows you to scale your Llama-2 training across multiple nodes with minimal code changes. Ray's actor-based architecture and task-based parallelism enable efficient execution of distributed workloads."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Flexible Strategies"}),": RayTrain supports various distributed training strategies such as data parallelism and model parallelism. Data parallelism splits the dataset across multiple nodes, while model parallelism splits the model itself. This flexibility allows you to optimize training based on the specific needs of your model and the architecture of your training environment."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Fault Tolerance"}),": RayTrain includes built-in fault tolerance mechanisms. If a node fails, Ray can reschedule the tasks on other available nodes, ensuring that the training job continues without interruption. This feature is crucial for maintaining robustness in large-scale distributed training environments."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Ease of Use"}),": RayTrain offers intuitive APIs that simplify the setup and execution of distributed training jobs. Integrations with popular machine learning libraries like Hugging Face Transformers make it easier to incorporate RayTrain into your existing workflows without extensive modifications."]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"kuberay",children:"KubeRay:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Integration with Kubernetes"}),": KubeRay leverages Kubernetes' native capabilities to deploy, manage, and scale Ray clusters. This integration allows you to use Kubernetes' robust orchestration features to handle Ray workloads effectively."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Dynamic Scaling"}),": KubeRay supports dynamic scaling of Ray clusters. Ray's built-in autoscaler can request additional actor replicas based on workload demands, while Kubernetes tools like Karpenter or Cluster Autoscaler manage the creation of new nodes to meet these demands."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Horizontal Scaling"}),": Scale your Ray clusters horizontally by adding more worker nodes as the computational load increases. This allows efficient handling of large-scale distributed training and inference tasks."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Custom Resource Definitions (CRDs)"}),": KubeRay utilizes Kubernetes CRDs to define and manage Ray clusters and jobs. This provides a standardized way to handle Ray workloads within the Kubernetes ecosystem."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Fault Tolerance"}),": KubeRay takes advantage of Kubernetes' self-healing capabilities. If a Ray head node or worker node fails, Kubernetes automatically restarts the failed components, ensuring minimal downtime and continuous operation."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Distributed Scheduling"}),": Ray's actor-based model and distributed task scheduling, combined with Kubernetes' orchestration, ensure high availability and efficient task execution even in the event of node failures."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Declarative Configuration"}),": KubeRay allows you to define Ray clusters and jobs using declarative YAML configurations. This simplifies the deployment and management process, making it easier to set up and maintain Ray clusters."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Integrated Logging and Monitoring"}),": KubeRay integrates with Kubernetes' logging and monitoring tools, such as Prometheus and Grafana. This provides comprehensive insights into the performance and health of Ray clusters, facilitating easier debugging and optimization."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Spot Instances"}),": Use Kubernetes' support for spot instances to run Ray clusters cost-effectively. This allows you to take advantage of lower-cost compute resources while maintaining the ability to scale as needed."]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"aws-trainium",children:"AWS Trainium:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Optimized for Deep Learning"}),": AWS Trainium-based Trn1 instances are specifically designed for deep learning workloads. They offer high throughput and low latency, making them ideal for training large-scale models like Llama-2. Trainium chips provide significant performance improvements over traditional processors, accelerating training times."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Neuron SDK"}),": The AWS Neuron SDK is tailored to optimize your deep learning models for Trainium. It includes features like advanced compiler optimizations and support for mixed precision training, which can further accelerate your training workloads while maintaining accuracy."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"why-this-combination-is-powerful",children:"Why This Combination is Powerful"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Simplified Scaling"}),": RayTrain and KubeRay simplify the process of scaling Llama-2 training across multiple nodes. With Ray's efficient distributed execution and KubeRay's Kubernetes-native orchestration, you can easily scale your training workloads to leverage the full power of AWS Trainium on Trn1 instances."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Optimized Performance"}),": The Neuron SDK enhances the performance of your training jobs by optimizing them specifically for Trainium's architecture. Combined with Ray's ability to efficiently manage distributed tasks and KubeRay's resource orchestration, this setup ensures optimal training performance."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cost-Effective"}),": Ray's autoscaling capabilities and Kubernetes' resource management help you optimize costs by efficiently allocating resources and scaling your cluster based on demand. This ensures you only use the resources you need, reducing unnecessary expenditure."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"By using this combination of technologies, you can take advantage of the latest advancements in distributed training and hardware to pre-train Llama-2 efficiently and effectively."}),"\n",(0,i.jsx)(n.h3,{id:"what-is-volcano",children:"What is Volcano?"}),"\n",(0,i.jsx)(n.p,{children:"Volcano is an open-source batch scheduling system built on Kubernetes, specifically designed to manage high-performance computing (HPC) and machine learning workloads. It provides advanced scheduling capabilities such as gang scheduling, fair sharing, and preemption, which are essential for efficiently running large-scale, distributed training jobs in a Kubernetes environment."}),"\n",(0,i.jsx)(n.h3,{id:"how-volcano-works-with-gang-scheduling",children:"How Volcano Works with Gang Scheduling"}),"\n",(0,i.jsx)(n.p,{children:'Volcano\'s gang scheduling ensures that all pods in a job (or "gang") are scheduled simultaneously. This is critical for distributed training workloads where multiple pods need to start together to function correctly. If even one pod in the gang cannot be scheduled due to resource constraints, none of the pods in the gang will start. This prevents partial execution and ensures that all resources required for the job are available before execution begins.'}),"\n",(0,i.jsx)(n.h2,{id:"1-deploying-the-solution",children:"1. Deploying the Solution"}),"\n",(0,i.jsxs)(r.A,{header:(0,i.jsx)(n.h2,{children:(0,i.jsx)(n.span,{children:"Prerequisites"})}),children:[(0,i.jsx)(n.p,{children:"Before we begin, ensure you have all the prerequisites in place to make the deployment process smooth and hassle-free.\nEnsure that you have installed the following tools on your EC2 or Cloud9 instance."}),(0,i.jsxs)(n.admonition,{type:"info",children:[(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EC2_GetStarted.html",children:"EC2 Instance"})," or ",(0,i.jsx)(n.a,{href:"https://docs.aws.amazon.com/cloud9/latest/user-guide/tutorial-create-environment.html",children:"Cloud9 instance"})," \u2192 Ensure you have 100GB+ of storage for both options. This is crucial for creating a Docker image with x86 architecture and having the right amount of storage."]}),"\n"]}),(0,i.jsx)(n.p,{children:"If you are using a local Windows machine or Mac, ensure you have Docker installed locally with builder storage above 100GB and the image is created with x86 architecture."})]}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2.html",children:"AWS CLI"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://Kubernetes.io/docs/tasks/tools/",children:"kubectl"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://learn.hashicorp.com/tutorials/terraform/install-cli",children:"terraform"})}),"\n"]}),(0,i.jsxs)(n.p,{children:["To install all the pre-reqs on EC2, you can run this ",(0,i.jsx)(n.a,{href:"https://github.com/awslabs/data-on-eks/blob/main/ai-ml/trainium-inferentia/examples/llama2/install-pre-requsites-for-ec2.sh",children:"script"})," which is compatible with Amazon Linux 2023."]}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Clone the Data on EKS repository"})}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"git clone https://github.com/awslabs/data-on-eks.git\n"})}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Navigate to the trainium-inferentia directory."})}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"cd data-on-eks/ai-ml/trainium-inferentia\n"})}),(0,i.jsx)(n.p,{children:"Let's run the below export commands to set environment variables."}),(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"NOTE:"})," As of 2024/01/04 Trainium instances only available in us-west-2, us-east-1, and us-east-2 regions."]})}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Enable FSx for Lustre, which will mount pre-training data to all pods across multiple nodes\nexport TF_VAR_enable_fsx_for_lustre=true\n\n# Set the region according to your requirements. Check Trn1 instance availability in the specified region.\nexport TF_VAR_region=us-west-2\n\n# Enable Volcano custom scheduler with KubeRay Operator\nexport TF_VAR_enable_volcano=true\n\n# Note: This configuration will create two new Trn1 32xl instances. Ensure you validate the associated costs before proceeding.\nexport TF_VAR_trn1_32xl_min_size=2\nexport TF_VAR_trn1_32xl_desired_size=2\n"})}),(0,i.jsx)(n.p,{children:"Run the installation script to provision an EKS cluster with all the add-ons needed for the solution."}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"./install.sh\n"})}),(0,i.jsx)(n.h3,{id:"verify-the-resources",children:"Verify the resources"}),(0,i.jsx)(n.p,{children:"Verify the Amazon EKS Cluster"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"aws eks --region us-west-2 describe-cluster --name trainium-inferentia\n"})}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Creates k8s config file to authenticate with EKS\naws eks --region us-west-2 update-kubeconfig --name trainium-inferentia\n\nkubectl get nodes # Output shows the EKS Managed Node group nodes\n"})})]}),"\n",(0,i.jsx)(n.h2,{id:"2-build-the-docker-image-optional-step",children:"2. Build the Docker Image (Optional Step)"}),"\n",(0,i.jsxs)(n.p,{children:["To simplify the blueprint deployment, we have already built the Docker image and made it available under the public ECR.\nIf you want to customize the Docker image, you can update the ",(0,i.jsx)(n.code,{children:"Dockerfile"})," and follow the optional step to build the Docker image.\nPlease note that you will also need to modify the RayCluster YAML file, ",(0,i.jsx)(n.code,{children:"llama2-pretrain-trn1-raycluster.yaml"}),", with the newly created image using your own private ECR."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"cd gen-ai/training/raytrain-llama2-pretrain-trn1\n./kuberay-trn1-llama2-pretrain-build-image.sh\n"})}),"\n",(0,i.jsx)(n.p,{children:"After running this script, note the Docker image URL and tag that are produced.\nYou will need this information for the next step."}),"\n",(0,i.jsx)(n.h2,{id:"3-launch-the-ray-cluster-with-kuberay-operator",children:"3. Launch the Ray Cluster with KubeRay Operator"}),"\n",(0,i.jsxs)(n.p,{children:["If you skip step 2, you don't need to modify the YAML file.\nYou can simply run the ",(0,i.jsx)(n.code,{children:"kubectl apply"})," command on the file, and it will use the public ECR image that we published."]}),"\n",(0,i.jsxs)(n.p,{children:["If you built a custom Docker image in ",(0,i.jsx)(n.strong,{children:"Step 2"}),", update the ",(0,i.jsx)(n.code,{children:"gen-ai/training/raytrain-llama2-pretrain-trn1/llama2-pretrain-trn1-raycluster.yaml"})," file with the Docker image URL and tag obtained from the previous step."]}),"\n",(0,i.jsx)(n.p,{children:"Once you have updated the YAML file (if needed), run the following command to launch the KubeRay cluster pods in your EKS cluster:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"kubectl apply -f llama2-pretrain-trn1-raycluster.yaml\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Verify the Pod Status:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'kubectl get pods -l "ray.io/cluster=kuberay-trn1"\n'})}),"\n",(0,i.jsx)(n.h3,{id:"gang-scheduling-of-ray-head-and-worker-pods-with-volcano",children:"Gang Scheduling of Ray Head and Worker Pods with Volcano"}),"\n",(0,i.jsxs)(n.p,{children:["In the context of deploying a Ray cluster for training Llama2, Volcano is crucial for ensuring that the Ray head and worker pods are scheduled together efficiently.\nThe Ray head pod, typically running on an x86 instance, coordinates the distributed training, while the worker pods, running on AWS Trainium (Trn1) instances, perform the computationally intensive tasks.\nBy leveraging ",(0,i.jsx)(n.strong,{children:"Volcano's gang scheduling"}),", we can ensure that the head and all worker pods are allocated the necessary resources simultaneously, enabling the distributed training job to start without delays."]}),"\n",(0,i.jsx)(n.p,{children:"Here's an example configuration for integrating Volcano with a RayCluster for Llama2 training:"}),"\n",(0,i.jsxs)(n.admonition,{type:"info",children:[(0,i.jsxs)(n.p,{children:["We are using the default namespace for this deployment because the ",(0,i.jsx)(n.code,{children:"fsx-claim"})," ",(0,i.jsx)(n.strong,{children:"PVC"})," is created under the ",(0,i.jsx)(n.code,{children:"default"})," namespace by the Terraform blueprint."]}),(0,i.jsx)(n.p,{children:"If you want to deploy the cluster in a dedicated namespace, ensure that the FSX for Lustre file system is also created in the same namespace since PVCs are namespace-bound."})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"# Docs for Volcano with KubeRay: https://docs.ray.io/en/master/cluster/kubernetes/k8s-ecosystem/volcano.html\n---\napiVersion: scheduling.volcano.sh/v1beta1\nkind: Queue\nmetadata:\n  name: llama2-training-queue\n  namespace: default\nspec:\n  weight: 1\n  capability:\n    cpu: '500'\n    memory: 1500Gi\n\n---\napiVersion: ray.io/v1\nkind: RayCluster\nmetadata:\n  name: kuberay-trn1\n  namespace: default\n  labels:\n    ray.io/scheduler-name: volcano\n    volcano.sh/queue-name: llama2-training-queue\nspec:\n  rayVersion: 2.22.0\n  headGroupSpec:\n...\n...\n"})}),"\n",(0,i.jsx)(n.p,{children:"You should see one ray-head pod and two ray-worker pods in the Running state:"}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsx)(n.p,{children:"Please be aware that it may take up to 10 minutes for the image to be pulled and the pod to become ready."})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"NAME                                    READY   STATUS    RESTARTS   AGE\nkuberay-trn1-head-67t46                 0/1     Pending   0          2m50s\nkuberay-trn1-worker-workergroup-fz8bs   0/1     Pending   0          2m50s\nkuberay-trn1-worker-workergroup-gpnxh   0/1     Pending   0          2m50s\n"})}),"\n",(0,i.jsx)(n.p,{children:"Check the logs of the head pod:"}),"\n",(0,i.jsx)(n.p,{children:"Look for messages indicating that the Ray head has started and the cluster is operational."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"kubectl logs kuberay-trn1-head-xxxxx\n"})}),"\n",(0,i.jsx)(n.h3,{id:"accessing-the-ray-dashboard-port-forwarding",children:"Accessing the Ray Dashboard (Port Forwarding):"}),"\n",(0,i.jsx)(n.p,{children:"The Ray dashboard provides valuable insights into your cluster's status and job progress. To access it:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Forward the Port:"})}),"\n",(0,i.jsx)(n.p,{children:"This forwards the Ray dashboard port (8265) from your local machine to the head pod within the cluster."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"kubectl port-forward service/kuberay-trn1-head-svc 8265:8265\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Open Browser and navigate to ",(0,i.jsx)(n.a,{href:"http://localhost:8265",children:"http://localhost:8265"})," in your web browser to view the dashboard."]}),"\n",(0,i.jsx)(n.h2,{id:"4-generate-pre-training-data-on-fsx-shared-filesystem",children:"4. Generate Pre-training Data on FSx Shared Filesystem"}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsx)(n.p,{children:"Data generation step can take up to 20 minutes to create all the data in FSx for Lustre."})}),"\n",(0,i.jsx)(n.p,{children:"In this step, we'll leverage KubeRay's Job specification to kickstart the data generation process. We'll submit a job directly to the Ray head pod. This job plays a key role in preparing your model for training."}),"\n",(0,i.jsxs)(n.p,{children:["Check out the ",(0,i.jsx)(n.code,{children:"RayJob"})," definition spec below to leverage the existing RayCluster using ",(0,i.jsx)(n.code,{children:"clusterSelector"})," to submit the jobs to RayCluster."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# ----------------------------------------------------------------------------\n# RayJob: llama2-generate-pretraining-test-data\n#\n# Description:\n# This RayJob is responsible for generating pre-training test data required for\n# the Llama2 model training. It sources data from the specified dataset, processes\n# it, and prepares it for use in subsequent training stages. The job runs a Python\n# script (`get_dataset.py`) that performs these data preparation steps.\n\n# Usage:\n# Apply this configuration to your Kubernetes cluster using `kubectl apply -f 1-llama2-pretrain-trn1-rayjob-create-test-data.yaml`.\n# Ensure that the Ray cluster (`kuberay-trn1`) is running and accessible in the specified namespace.\n# ----------------------------------------------------------------------------\n\napiVersion: ray.io/v1\nkind: RayJob\nmetadata:\n  name: llama2-generate-pretraining-test-data\n  namespace: default\nspec:\n  submissionMode: K8sJobMode\n  entrypoint: "python3 get_dataset.py"\n  runtimeEnvYAML: |\n    working_dir: /llama2_pretrain\n    env_vars:\n      PYTHONUNBUFFERED: \'0\'\n    resources:\n      requests:\n        cpu: "6"\n        memory: "30Gi"\n  clusterSelector:\n    ray.io/cluster: kuberay-trn1\n    rayClusterNamespace: default  # Replace with the namespace where your RayCluster is deployed\n  ttlSecondsAfterFinished: 60  # Time to live for the pod after completion (in seconds)\n'})}),"\n",(0,i.jsx)(n.p,{children:"Execute the following command to run the Test Data creation Ray job:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"kubectl apply -f 1-llama2-pretrain-trn1-rayjob-create-test-data.yaml\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"What Happens Behind the Scenes:"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Job Launch:"})," You'll use kubectl to submit the KubeRay job specification. The Ray head pod in your ",(0,i.jsx)(n.code,{children:"kuberay-trn1"})," cluster receives and executes this job."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Data Generation:"})," The job runs the ",(0,i.jsx)(n.code,{children:"gen-ai/training/raytrain-llama2-pretrain-trn1/llama2_pretrain/get_dataset.py"}),' script, which harnesses the power of the Hugging Face datasets library to fetch and process the raw English Wikipedia dataset ("wikicorpus").']}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Tokenization:"})," The script tokenizes the text using a pre-trained tokenizer from Hugging Face transformers. Tokenization breaks down the text into smaller units (words or subwords) for the model to understand."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Data Storage:"})," The tokenized data is neatly organized and saved to a specific directory (",(0,i.jsx)(n.code,{children:"/shared/wikicorpus_llama2_7B_tokenized_4k/"}),") within your FSx for Lustre shared filesystem. This ensures all worker nodes in your cluster can readily access this standardized data during pre-training."]}),"\n",(0,i.jsx)(n.h3,{id:"monitoring-the-job",children:"Monitoring the Job:"}),"\n",(0,i.jsx)(n.p,{children:"To keep tabs on the job's progress:"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Ray Dashboard"}),": Head over to the Ray dashboard, accessible via your Ray head pod's IP address and port 8265. You'll see real-time updates on the job's status."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Prepare the Dataset",src:a(5526).A+"",width:"3022",height:"934"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Prepare the Dataset",src:a(7149).A+"",width:"3022",height:"934"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Prepare the Dataset",src:a(4823).A+"",width:"3022",height:"1642"})}),"\n",(0,i.jsx)(n.p,{children:"Alternatively, you can use the following command in your terminal:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"kubectl get pods | grep llama2\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Output:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"llama2-generate-pretraining-test-data-g6ccl   1/1     Running   0             5m5s\n"})}),"\n",(0,i.jsx)(n.p,{children:"The following screenshot taken from Lens K8s IDE to show the logs of the pod."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Prepare the Dataset",src:a(819).A+"",width:"3022",height:"1628"})}),"\n",(0,i.jsx)(n.h2,{id:"5-run-pre-compilation-job-optimization-step",children:"5. Run Pre-compilation Job (Optimization Step)"}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsx)(n.p,{children:"Pre-compilation job can take upto 6 min"})}),"\n",(0,i.jsxs)(n.p,{children:["Before starting the actual training, we'll perform a pre-compilation step to optimize the model for the Neuron SDK. This helps the model run more efficiently on the ",(0,i.jsx)(n.code,{children:"Trn1"})," instances. This script will use the Neuron SDK to compile and optimize the model's computational graph, making it ready for efficient training on the Trn1 processors."]}),"\n",(0,i.jsxs)(n.p,{children:["In this step, you will run a pre-compilation job where the Neuron SDK will identify, compile, and cache the compute graphs associated with ",(0,i.jsx)(n.code,{children:"Llama2"})," pretraining."]}),"\n",(0,i.jsxs)(n.p,{children:["Check out the ",(0,i.jsx)(n.code,{children:"RayJob"})," definition spec below to run the pre-compilation job:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"# ----------------------------------------------------------------------------\n# RayJob: llama2-precompilation-job\n#\n# Description:\n# This RayJob is responsible for the pre-compilation step required for the Llama2 model\n# training. It runs a Python script (`ray_train_llama2.py`) with the `--neuron_parallel_compile`\n# option to compile the model in parallel using AWS Neuron devices. This step is crucial for\n# optimizing the model for efficient training on AWS infrastructure.\n\n# Usage:\n# Apply this configuration to your Kubernetes cluster using `kubectl apply -f 2-llama2-pretrain-trn1-rayjob-precompilation.yaml`.\n# Ensure that the Ray cluster (`kuberay-trn1`) is running and accessible in the specified namespace.\n# ----------------------------------------------------------------------------\n\n---\napiVersion: ray.io/v1\nkind: RayJob\nmetadata:\n  name: llama2-precompilation-job\n  namespace: default\nspec:\n  submissionMode: K8sJobMode\n  entrypoint: \"NEURON_NUM_DEVICES=32 python3 /llama2_pretrain/ray_train_llama2.py --neuron_parallel_compile\"\n  runtimeEnvYAML: |\n    working_dir: /llama2_pretrain\n    env_vars:\n      PYTHONUNBUFFERED: '0'\n  clusterSelector:\n    ray.io/cluster: kuberay-trn1\n    rayClusterNamespace: default  # Replace with the namespace where your RayCluster is deployed\n  ttlSecondsAfterFinished: 60  # Time to live for the pod after completion (in seconds)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Execute the following command to run the pre-compilation job:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"kubectl apply -f 2-llama2-pretrain-trn1-rayjob-precompilation.yaml\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Verification Steps:"})}),"\n",(0,i.jsx)(n.p,{children:"To monitor the job's progress and verify that it is running correctly, use the following commands and tools:"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Ray Dashboard:"})," Access the Ray dashboard via your Ray head pod's IP address and port ",(0,i.jsx)(n.code,{children:"8265"})," to see real-time updates on the job's status."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Precompilation progress",src:a(8593).A+"",width:"3814",height:"1818"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Precompilation progress",src:a(4362).A+"",width:"3814",height:"1818"})}),"\n",(0,i.jsx)(n.p,{children:"The following screenshot taken from Lens K8s IDE to show the logs of the pod."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Precompilation progress",src:a(3219).A+"",width:"1922",height:"907"})}),"\n",(0,i.jsx)(n.h2,{id:"6-run-distributed-pre-training-job",children:"6. Run Distributed Pre-training Job"}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsx)(n.p,{children:"This job can run for many hours so feel free to cancel the job using Ctrl+C once you are convinced that the loss is decreasing and the model is learning."})}),"\n",(0,i.jsx)(n.p,{children:"Now, you're ready to begin the actual training of the Llama 2 model! This step involves running the distributed pre-training job using a RayJob. The job will utilize AWS Neuron devices to efficiently train the model with the prepared dataset."}),"\n",(0,i.jsxs)(n.p,{children:["Check out the ",(0,i.jsx)(n.code,{children:"RayJob"})," definition spec below to run the pretraining job:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"# ----------------------------------------------------------------------------\n# RayJob: llama2-pretraining-job\n#\n# Description:\n# This RayJob is responsible for the main pretraining step of the Llama2 model.\n# It runs a Python script (`ray_train_llama2.py`) to perform the pretraining using AWS Neuron devices.\n# This step is critical for training the language model with the prepared dataset.\n\n# Usage:\n# Apply this configuration to your Kubernetes cluster using `kubectl apply -f 3-llama2-pretrain-trn1-rayjob.yaml`.\n# Ensure that the Ray cluster (`kuberay-trn1`) is running and accessible in the specified namespace.\n# ----------------------------------------------------------------------------\n\n---\napiVersion: ray.io/v1\nkind: RayJob\nmetadata:\n  name: llama2-pretraining-job\n  namespace: default\nspec:\n  submissionMode: K8sJobMode\n  entrypoint: \"NEURON_NUM_DEVICES=32 python3 ray_train_llama2.py\"\n  runtimeEnvYAML: |\n    working_dir: /llama2_pretrain\n    env_vars:\n      PYTHONUNBUFFERED: '0'\n  clusterSelector:\n    ray.io/cluster: kuberay-trn1\n    rayClusterNamespace: default  # Replace with the namespace where your RayCluster is deployed\n  shutdownAfterJobFinishes: true\n  activeDeadlineSeconds: 600   # The job will be terminated if it runs longer than 600 seconds (10 minutes)\n  ttlSecondsAfterFinished: 60  # Time to live for the pod after completion (in seconds)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Execute the following command to run the pretraining job:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"kubectl apply -f 3-llama2-pretrain-trn1-rayjob.yaml\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Monitor Progress:"})}),"\n",(0,i.jsx)(n.p,{children:"You can monitor the progress of the training job using the Ray Dashboard or by observing the logs output to your terminal. Look for information like the training loss, learning rate, and other metrics to assess how well the model is learning."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Training Progress",src:a(1631).A+"",width:"3814",height:"1818"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Ray Dashboard:"})," Access the Ray dashboard via your Ray head pod's IP address and port 8265 to see real-time updates on the job's status."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Training Progress Ray Dashboard",src:a(8068).A+"",width:"3814",height:"1818"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Training Progress Ray Dashboard",src:a(4221).A+"",width:"3814",height:"1818"})}),"\n",(0,i.jsx)(n.h3,{id:"cleaning-up",children:"Cleaning up"}),"\n",(0,i.jsx)(n.p,{children:"To remove the resources created using this solution, run the cleanup script:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Delete the RayCluster Resources:\ncd gen-ai/training/raytrain-llama2-pretrain-trn1\nkubectl delete -f llama2-pretrain-trn1-raycluster.yaml\n\n# Clean Up the EKS Cluster and Associated Resources:\ncd data-on-eks/ai-ml/trainium-inferentia\n./cleanup.sh\n"})})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},2450:(e,n,a)=>{a.d(n,{A:()=>g});var i=a(6540),t=a(5556),r=a.n(t),s=a(4164);const o="collapsibleContent_q3kw",l="header_QCEw",d="icon_PckA",c="content_qLC1",h="expanded_iGsi";var u=a(4848);function p(e){let{children:n,header:a}=e;const[t,r]=(0,i.useState)(!1);return(0,u.jsxs)("div",{className:o,children:[(0,u.jsxs)("div",{className:(0,s.A)(l,{[h]:t}),onClick:()=>{r(!t)},children:[a,(0,u.jsx)("span",{className:(0,s.A)(d,{[h]:t}),children:t?"\ud83d\udc47":"\ud83d\udc48"})]}),t&&(0,u.jsx)("div",{className:c,children:n})]})}p.propTypes={children:r().node.isRequired,header:r().node.isRequired};const g=p},2709:(e,n,a)=>{a.d(n,{A:()=>i});const i=a.p+"assets/images/Llama2-RayTrain-Trn1-d93433eba0c8e8e7c617a9fa1b17f249.png"},8593:(e,n,a)=>{a.d(n,{A:()=>i});const i=a.p+"assets/images/raytrain-precomplilation1-777f1caf778704cc0021889c8968ec58.png"},4362:(e,n,a)=>{a.d(n,{A:()=>i});const i=a.p+"assets/images/raytrain-precomplilation2-705da082daec14cb61c6b27f566e0dab.png"},3219:(e,n,a)=>{a.d(n,{A:()=>i});const i=a.p+"assets/images/raytrain-precomplilation3-fe1f06d03638e88e965c106514105218.png"},819:(e,n,a)=>{a.d(n,{A:()=>i});const i=a.p+"assets/images/raytrain-testdata-lens-7a27be9b9fca7ff7389068a5e8e1f06b.png"},5526:(e,n,a)=>{a.d(n,{A:()=>i});const i=a.p+"assets/images/raytrain-testdata-raydash1-b4670a064fa2d403d5710ccbaf639df7.png"},7149:(e,n,a)=>{a.d(n,{A:()=>i});const i=a.p+"assets/images/raytrain-testdata-raydash2-d587f6edbefc961341e179b801414f5d.png"},4823:(e,n,a)=>{a.d(n,{A:()=>i});const i=a.p+"assets/images/raytrain-testdata-raydash3-09f961034e80ed2f517469333f748079.png"},1631:(e,n,a)=>{a.d(n,{A:()=>i});const i=a.p+"assets/images/raytrain-training-progress1-a0075f05772879597fe736982d834b18.png"},8068:(e,n,a)=>{a.d(n,{A:()=>i});const i=a.p+"assets/images/raytrain-training-progress2-52bb1ff83523781d2048dbf00670e901.png"},4221:(e,n,a)=>{a.d(n,{A:()=>i});const i=a.p+"assets/images/raytrain-training-progress3-b614686ce3efb30717a77a20ddfe39a6.png"},8453:(e,n,a)=>{a.d(n,{R:()=>s,x:()=>o});var i=a(6540);const t={},r=i.createContext(t);function s(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);